{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n",
      "[4, 12, 9]\n",
      "[3, 9, 8]\n",
      "4\n",
      "[13, 7, 1, 4]\n",
      "[8, 6, 9, 6]\n",
      "4\n",
      "[5, 10, 14, 7]\n",
      "[0, 4, 6, 6]\n",
      "3\n",
      "[6, 4, 6]\n",
      "[1, 3, 4]\n",
      "3\n",
      "[4, 12, 9]\n",
      "[3, 5, 5]\n",
      "4\n",
      "[5, 5, 0, 0]\n",
      "[3, 1, 2, 7]\n",
      "3\n",
      "[13, 13, 4]\n",
      "[7, 8, 6]\n",
      "3\n",
      "[13, 12, 11]\n",
      "[1, 8, 6]\n",
      "4\n",
      "[13, 4, 13, 2]\n",
      "[9, 9, 4, 5]\n",
      "4\n",
      "[3, 2, 5, 14]\n",
      "[0, 8, 8, 3]\n",
      "4\n",
      "[6, 8, 0, 2]\n",
      "[3, 4, 9, 3]\n",
      "4\n",
      "[13, 11, 10, 11]\n",
      "[6, 6, 4, 8]\n",
      "3\n",
      "[10, 12, 11]\n",
      "[3, 1, 6]\n",
      "4\n",
      "[4, 6, 4, 2]\n",
      "[1, 4, 6, 5]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[['niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly'],\n",
       " ['niggerdly', 'niggerdly', 'niggerdly', 'niggerdly']]"
      ]
     },
     "execution_count": 50,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from __future__ import print_function\n",
    "from __future__ import division\n",
    "from scipy.integrate import quad\n",
    "from scipy.linalg import norm\n",
    "import random \n",
    "import numpy as np \n",
    "\n",
    "L = 15\n",
    "M = 10\n",
    "\n",
    "S = np.random.uniform(size=L)    # initialize a start state distribution S for the HMM \n",
    "S = np.divide(S, np.sum(S))      # normalize the vector to 1 \n",
    "\n",
    "\n",
    "# the rows of A are the target states and the columns of A are the start states. \n",
    "    # given a start state, one of the target states must be choosen so each column is normalized\n",
    "A = np.random.rand(L, L) \n",
    "for i in range(L): \n",
    "    A[:,i] = np.divide(A[:,i], np.sum(A[:,i]))    \n",
    "\n",
    "    # given some hidden state, there must be some observation, so every row of this matrix should\n",
    "    # be normalized\n",
    "O = np.random.rand(L, M) \n",
    "for i in range(L):\n",
    "    O[i,:] = np.divide(O[i,:], np.sum(O[i,:])) \n",
    "\n",
    "    \n",
    "    \n",
    "    \n",
    "\n",
    "\n",
    "average_length = 4\n",
    "std = .001\n",
    "rhyming_dict = {}\n",
    "syllables_dict = {}\n",
    "states_to_words_dict = {}\n",
    "\n",
    "\n",
    "def convert_to_words(n):\n",
    "    words = []\n",
    "    for num in n:\n",
    "        #words.append(states_to_words_dict[num])\n",
    "        words.append(\"niggerdly\")\n",
    "    \n",
    "    return words\n",
    "\n",
    "def check_syllables(words):\n",
    "    syllables = 0\n",
    "    for word in words:\n",
    "        syllables += syllabes_dict[word]\n",
    "    \n",
    "    return syllables\n",
    "\n",
    "def pick_start(S):\n",
    "    \n",
    "    pick = random.random()\n",
    "    \n",
    "    for i in range(S.shape[0]):\n",
    "        pick = pick - S[i]\n",
    "        if pick <= 0:\n",
    "            return i\n",
    "    \n",
    "    \n",
    "    return 0\n",
    "\n",
    "def pick_rhyming_start(S, A, O, rhyme):\n",
    "    \n",
    "    rhyme_start = np.zeroes(S.shape)\n",
    "    for i in range(O.shape[1]):\n",
    "        for j in range(rhyme_start.shape[0]):\n",
    "            rhyme_start[j] += O[i][rhyme]*A[j][i]\n",
    "    \n",
    "    return rhyme_start\n",
    "\n",
    "def pick_next(A, current):\n",
    "    \n",
    "    pick = random.random()\n",
    "    for i in range(A.shape[0]):\n",
    "        pick = pick - A[i][current]\n",
    "        if pick <= 0:\n",
    "            return i\n",
    "    \n",
    "    \n",
    "    return 0\n",
    "\n",
    "def convert_to_observed(states, O):\n",
    "    observed = []\n",
    "    \n",
    "    for state in states:\n",
    "        pick = random.random()\n",
    "        for i in range(O.shape[1]):\n",
    "            pick = pick - O[state][i]\n",
    "            if pick <= 0:\n",
    "                observed.append(i)\n",
    "                break\n",
    "    \n",
    "    \n",
    "    return observed\n",
    "\n",
    "def gen_line(A, O, start, length):\n",
    "    \n",
    "    syllables_right = False\n",
    "    \n",
    "    while (syllables_right == False):\n",
    "        \n",
    "        hidden_states = []\n",
    "        current = start\n",
    "        hidden_states.append(current)\n",
    "        \n",
    "        for i in range(length - 1):\n",
    "            current = pick_next(A, current)\n",
    "            hidden_states.append(current)\n",
    "        \n",
    "        print (hidden_states)\n",
    "        observed_states = convert_to_observed(hidden_states, O)\n",
    "        print (observed_states)\n",
    "        current_line = convert_to_words(observed_states)\n",
    "        \n",
    "        syllables_right = True\n",
    "        #syllables = check_syllables(current_line)\n",
    "        \n",
    "        #if syllables == 10:\n",
    "            #syllables_right = True\n",
    "            \n",
    "    return current_line\n",
    "\n",
    "def gen_couplets(A, O, S, avg_words, std):\n",
    "    length = int(np.random.normal(avg_words, std))\n",
    "    print (length)\n",
    "    start = pick_start(S)\n",
    "    line1 = gen_line(A, O, start, length)\n",
    "    \n",
    "    length = int(np.random.normal(avg_words, std))\n",
    "    print (length)\n",
    "    start = pick_start(S)\n",
    "    line2 = gen_line(A, O, start, length)\n",
    "    \n",
    "    \n",
    "    #length = np.random.normal(avg_words, std) - 1\n",
    "    #rhyming = random.choice(rhyming_dict[line1[-1]])\n",
    "    #S_rhyme = pick_rhyming_start(line1[-1])\n",
    "    #start = pick_rhyming_start(S_rhyme)\n",
    "    #line2 = gen_line(A, O, start, length) + rhyming\n",
    "    \n",
    "    return (line1, line2)\n",
    "\n",
    "def poem_gen(S, A, O, avg_words, std):\n",
    "    \n",
    "    poem = []\n",
    "    for i in range(14):\n",
    "        poem.append([])\n",
    "    \n",
    "    for i in range(3):\n",
    "        for j in range(2):\n",
    "            (poem[4*i + j], poem[4*i + j + 2]) = gen_couplets(A, O, S, avg_words, std)\n",
    "        \n",
    "    (poem[12], poem[13]) = gen_couplets(A, O, S, avg_words, std)\n",
    "\n",
    "    return poem\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "poem_gen(S, A, O, average_length, std)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
